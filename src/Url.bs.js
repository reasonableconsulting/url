// Generated by BUCKLESCRIPT VERSION 4.0.14, PLEASE EDIT WITH CARE
'use strict';

var $$Array = require("bs-platform/lib/js/array.js");
var Curry = require("bs-platform/lib/js/curry.js");
var $$String = require("bs-platform/lib/js/string.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

var empty = /* record */[
  /* href */"",
  /* protocol */undefined,
  /* slashes */false,
  /* origin */undefined,
  /* host */undefined,
  /* hostname */undefined,
  /* port */undefined,
  /* auth */undefined,
  /* username */undefined,
  /* password */undefined,
  /* pathname */undefined,
  /* querystring */undefined,
  /* hash */undefined
];

function isSome(opt) {
  return opt !== undefined;
}

function isNone(opt) {
  return opt === undefined;
}

function getWithDefault(opt, $$default) {
  if (opt !== undefined) {
    return Caml_option.valFromOption(opt);
  } else {
    return $$default;
  }
}

function mapWithDefault(opt, $$default, fn) {
  if (opt !== undefined) {
    return Curry._1(fn, Caml_option.valFromOption(opt));
  } else {
    return $$default;
  }
}

function flatMap(opt, fn) {
  if (opt !== undefined) {
    return Curry._1(fn, Caml_option.valFromOption(opt));
  }
  
}

function pop(arr) {
  try {
    return $$Array.sub(arr, 0, arr.length - 1 | 0);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.invalid_argument) {
      return arr;
    } else {
      throw exn;
    }
  }
}

function tail(arr) {
  try {
    return $$Array.sub(arr, 1, arr.length - 1 | 0);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.invalid_argument) {
      return /* array */[];
    } else {
      throw exn;
    }
  }
}

function first(arr) {
  var exit = 0;
  var el;
  try {
    el = Caml_array.caml_array_get(arr, 0);
    exit = 1;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.invalid_argument) {
      return undefined;
    } else {
      throw exn;
    }
  }
  if (exit === 1) {
    return Caml_option.some(el);
  }
  
}

function last(arr) {
  var exit = 0;
  var el;
  try {
    el = Caml_array.caml_array_get(arr, arr.length - 1 | 0);
    exit = 1;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.invalid_argument) {
      return undefined;
    } else {
      throw exn;
    }
  }
  if (exit === 1) {
    return Caml_option.some(el);
  }
  
}

function reduceRight(arr, start, fn) {
  return $$Array.fold_right((function (part, result) {
                return Curry._2(fn, result, part);
              }), arr, start);
}

function join(arr, sep) {
  var match = first(arr);
  if (match !== undefined) {
    var arr$1 = tail(arr);
    return $$Array.fold_left((function (result, part) {
                  return result + (sep + part);
                }), match, arr$1);
  } else {
    return "";
  }
}

function index(str, chr) {
  var exit = 0;
  var index$1;
  try {
    index$1 = $$String.index(str, chr);
    exit = 1;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return undefined;
    } else {
      throw exn;
    }
  }
  if (exit === 1) {
    return index$1;
  }
  
}

function slice(str, start, len) {
  var exit = 0;
  var sub;
  try {
    sub = $$String.sub(str, start, len);
    exit = 1;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.invalid_argument) {
      return undefined;
    } else {
      throw exn;
    }
  }
  if (exit === 1) {
    return sub;
  }
  
}

function length(str) {
  var exit = 0;
  var len;
  try {
    len = str.length;
    exit = 1;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.invalid_argument) {
      return undefined;
    } else {
      throw exn;
    }
  }
  if (exit === 1) {
    return len;
  }
  
}

function isEmpty(str) {
  var exit = 0;
  var len;
  try {
    len = str.length;
    exit = 1;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.invalid_argument) {
      return true;
    } else {
      throw exn;
    }
  }
  if (exit === 1) {
    return len === 0;
  }
  
}

function startsWith(str, chr) {
  var exit = 0;
  var index;
  try {
    index = $$String.index(str, chr);
    exit = 1;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return false;
    } else {
      throw exn;
    }
  }
  if (exit === 1) {
    return index === 0;
  }
  
}

function endsWith(str, chr) {
  var exit = 0;
  var val;
  var val$1;
  try {
    val = $$String.rindex(str, chr);
    val$1 = str.length;
    exit = 1;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn === Caml_builtin_exceptions.not_found || exn[0] === Caml_builtin_exceptions.invalid_argument) {
      return false;
    } else {
      throw exn;
    }
  }
  if (exit === 1) {
    return val === (val$1 - 1 | 0);
  }
  
}

function sliceToEnd(str, start) {
  var match = length(str);
  if (match !== undefined) {
    return slice(str, start, match - start | 0);
  }
  
}

function split(str, chr) {
  var match = index(str, chr);
  if (match !== undefined) {
    var index$1 = match;
    var beginChunk = getWithDefault(slice(str, 0, index$1), "");
    var endChunk = getWithDefault(sliceToEnd(str, index$1 + 1 | 0), "");
    return $$Array.append(/* array */[beginChunk], split(endChunk, chr));
  } else {
    return /* array */[str];
  }
}

function chunkEnd(str, index) {
  var rest = slice(str, 0, index);
  var endChunk = sliceToEnd(str, index);
  if (rest !== undefined) {
    return /* tuple */[
            endChunk,
            rest
          ];
  } else {
    return /* tuple */[
            undefined,
            str
          ];
  }
}

function toInt(str) {
  var exit = 0;
  var value;
  try {
    value = Caml_format.caml_int_of_string(str);
    exit = 1;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.failure) {
      return undefined;
    } else {
      throw exn;
    }
  }
  if (exit === 1) {
    return value;
  }
  
}

var protocolRegExp = (/^([a-z][a-z0-9.+-]*:)?(\/\/)?([\S\s]*)/i);

((/^[A-Za-z][A-Za-z0-9+-.]*:\/\//));

var portRegExp = (/:(\d+)$/);

var pathnameRegExp = (/(.*)/);

function hash(address) {
  var match = index(address, /* "#" */35);
  if (match !== undefined) {
    return chunkEnd(address, match);
  } else {
    return /* tuple */[
            undefined,
            address
          ];
  }
}

function querystring(address) {
  var match = index(address, /* "?" */63);
  if (match !== undefined) {
    return chunkEnd(address, match);
  } else {
    return /* tuple */[
            undefined,
            address
          ];
  }
}

function sanitize(address) {
  return $$String.map((function ($$char) {
                var match = $$char === /* "\\" */92;
                if (match) {
                  return /* "/" */47;
                } else {
                  return $$char;
                }
              }), address);
}

function pathnameWhenSlashes(address) {
  var address$1 = sanitize(address);
  var match = index(address$1, /* "/" */47);
  if (match !== undefined) {
    return chunkEnd(address$1, match);
  } else {
    return /* tuple */[
            undefined,
            address$1
          ];
  }
}

function pathnameWhenNoSlashes(address) {
  var match_ = pathnameRegExp.exec(address);
  if (match_ !== null) {
    var match = Caml_array.caml_array_get(match_, 1);
    var pathname = (match == null) ? undefined : flatMap(length(match), (function (length) {
              var match$1 = length > 0;
              if (match$1) {
                return match;
              }
              
            }));
    var match$1 = slice(address, 0, match_.index);
    if (match$1 !== undefined) {
      return /* tuple */[
              pathname,
              match$1
            ];
    } else {
      return /* tuple */[
              pathname,
              ""
            ];
    }
  } else {
    return /* tuple */[
            undefined,
            address
          ];
  }
}

function auth(address) {
  var match = index(address, /* "@" */64);
  if (match !== undefined) {
    var str = address;
    var index$1 = match;
    var rest = sliceToEnd(str, index$1 + 1 | 0);
    var beginChunk = slice(str, 0, index$1);
    if (rest !== undefined) {
      return /* tuple */[
              beginChunk,
              rest
            ];
    } else {
      return /* tuple */[
              undefined,
              str
            ];
    }
  } else {
    return /* tuple */[
            undefined,
            address
          ];
  }
}

function host(address) {
  if (isEmpty(address)) {
    return /* tuple */[
            undefined,
            address
          ];
  } else {
    return /* tuple */[
            $$String.lowercase(address),
            address
          ];
  }
}

function port(address) {
  var match_ = portRegExp.exec(address);
  if (match_ !== null) {
    var match = Caml_array.caml_array_get(match_, 1);
    var port$1 = (match == null) ? undefined : match;
    var match$1 = slice(address, 0, match_.index);
    if (match$1 !== undefined) {
      return /* tuple */[
              port$1,
              match$1
            ];
    } else {
      return /* tuple */[
              port$1,
              ""
            ];
    }
  } else {
    return /* tuple */[
            undefined,
            address
          ];
  }
}

function hostname(address) {
  if (isEmpty(address)) {
    return /* tuple */[
            undefined,
            address
          ];
  } else {
    return /* tuple */[
            $$String.lowercase(address),
            address
          ];
  }
}

function exec(_rules, _results, _address) {
  while(true) {
    var address = _address;
    var results = _results;
    var rules = _rules;
    if (rules) {
      var match = Curry._1(rules[0], address);
      var results_000 = match[0];
      var results$1 = /* :: */[
        results_000,
        results
      ];
      _address = match[1];
      _results = results$1;
      _rules = rules[1];
      continue ;
    } else {
      return results;
    }
  };
}

function requiresPort(port, protocol) {
  if (port !== undefined && protocol !== undefined) {
    var port$1 = port;
    var protocol$1 = first(split(protocol, /* ":" */58));
    if (protocol$1 !== undefined) {
      switch (protocol$1) {
        case "file" : 
            return false;
        case "ftp" : 
            return port$1 !== 21;
        case "gopher" : 
            return port$1 !== 70;
        case "http" : 
        case "ws" : 
            return port$1 !== 80;
        case "https" : 
        case "wss" : 
            return port$1 !== 443;
        default:
          return port$1 !== 0;
      }
    } else {
      return port$1 !== 0;
    }
  } else {
    return false;
  }
}

function extractProtocol(address) {
  var match_ = protocolRegExp.exec(address);
  if (match_ !== null) {
    var match = Caml_array.caml_array_get(match_, 1);
    var protocol = (match == null) ? undefined : $$String.lowercase(match);
    var match$1 = Caml_array.caml_array_get(match_, 2);
    var slashes = !(match$1 == null);
    var rest = Caml_array.caml_array_get(match_, 3);
    return /* tuple */[
            protocol,
            slashes,
            (rest == null) ? undefined : Caml_option.some(rest)
          ];
  } else {
    return /* tuple */[
            undefined,
            false,
            undefined
          ];
  }
}

function isAbsolute(str) {
  return startsWith(str, /* "/" */47);
}

function resolvePathname(to_, from, param) {
  var toParts = mapWithDefault(to_, /* array */[], (function (to_) {
          return split(to_, /* "/" */47);
        }));
  var fromParts = mapWithDefault(from, /* array */[], (function (from) {
          return split(from, /* "/" */47);
        }));
  var isToAbsolute = mapWithDefault(to_, false, isAbsolute);
  var isFromAbsolute = mapWithDefault(from, false, isAbsolute);
  var mustEndAbsolute = isToAbsolute || isFromAbsolute;
  var fromParts$1 = isToAbsolute ? toParts : (
      isSome(to_) ? $$Array.append(pop(fromParts), toParts) : fromParts
    );
  if (fromParts$1.length === 0) {
    return "/";
  } else {
    var lastSegment = last(fromParts$1);
    var needsTrailingSlash;
    if (lastSegment !== undefined) {
      switch (lastSegment) {
        case "" : 
        case "." : 
        case ".." : 
            needsTrailingSlash = true;
            break;
        default:
          needsTrailingSlash = false;
      }
    } else {
      needsTrailingSlash = false;
    }
    var up = /* record */[/* contents */0];
    var fromParts$2 = reduceRight(fromParts$1, /* array */[], (function (result, part) {
            switch (part) {
              case "." : 
                  return result;
              case ".." : 
                  up[0] = up[0] + 1 | 0;
                  return result;
              default:
                if (up[0] > 0) {
                  up[0] = up[0] - 1 | 0;
                  return result;
                } else {
                  return $$Array.append(/* array */[part], result);
                }
            }
          }));
    var fromParts$3 = mustEndAbsolute ? fromParts$2 : $$Array.append(Caml_array.caml_make_vect(up[0], ".."), fromParts$2);
    var fromParts$4;
    if (mustEndAbsolute) {
      var match = first(fromParts$3);
      if (match !== undefined) {
        var part = match;
        var match$1 = part !== "" && !startsWith(part, /* "/" */47);
        fromParts$4 = match$1 ? $$Array.append(/* array */[""], fromParts$3) : fromParts$3;
      } else {
        fromParts$4 = $$Array.append(/* array */[""], fromParts$3);
      }
    } else {
      fromParts$4 = fromParts$3;
    }
    var result = join(fromParts$4, "/");
    if (needsTrailingSlash && !endsWith(result, /* "/" */47)) {
      return result + "/";
    } else {
      return result;
    }
  }
}

function toString(url) {
  var match = url[/* slashes */2];
  return mapWithDefault(url[/* protocol */1], "", (function (protocol) {
                var match = endsWith(protocol, /* ":" */58);
                if (match) {
                  return protocol;
                } else {
                  return protocol + ":";
                }
              })) + ((
            match ? "//" : ""
          ) + (mapWithDefault(url[/* username */8], "", (function (username) {
                    return username + (mapWithDefault(url[/* password */9], "", (function (password) {
                                    return ":" + password;
                                  })) + "@");
                  })) + (getWithDefault(url[/* host */4], "") + (getWithDefault(url[/* pathname */10], "") + (mapWithDefault(url[/* querystring */11], "", (function (querystring) {
                          var match = startsWith(querystring, /* "?" */63);
                          if (match) {
                            return querystring;
                          } else {
                            return "?" + querystring;
                          }
                        })) + getWithDefault(url[/* hash */12], ""))))));
}

function makeWithLocation(protocol, $staropt$star, host, hostname, port, auth, username, password, pathname, querystring, hash, $$location) {
  var slashes = $staropt$star !== undefined ? $staropt$star : false;
  var relative = isNone(protocol) && slashes === false;
  var $$location$1 = getWithDefault($$location, empty);
  var slashes$1 = slashes || relative && $$location$1[/* slashes */2];
  var match = isSome(protocol);
  var protocol$1 = match ? protocol : $$location$1[/* protocol */1];
  var pathname$1 = relative && $$location$1[/* slashes */2] ? resolvePathname(pathname, $$location$1[/* pathname */10], /* () */0) : pathname;
  var match$1 = requiresPort(port, protocol$1) === false;
  var match$2 = match$1 ? /* tuple */[
      hostname,
      undefined
    ] : /* tuple */[
      host,
      port
    ];
  var port$1 = match$2[1];
  var host$1 = match$2[0];
  var match$3;
  if (auth !== undefined) {
    var match$4 = split(auth, /* ":" */58);
    var len = match$4.length;
    if (len >= 3) {
      match$3 = /* tuple */[
        username,
        password
      ];
    } else {
      switch (len) {
        case 0 : 
            match$3 = /* tuple */[
              username,
              password
            ];
            break;
        case 1 : 
            var username$1 = match$4[0];
            match$3 = /* tuple */[
              username$1,
              undefined
            ];
            break;
        case 2 : 
            var username$2 = match$4[0];
            var password$1 = match$4[1];
            match$3 = /* tuple */[
              username$2,
              password$1
            ];
            break;
        
      }
    }
  } else {
    match$3 = /* tuple */[
      username,
      password
    ];
  }
  var password$2 = match$3[1];
  var username$3 = match$3[0];
  var origin;
  if (protocol$1 !== undefined && host$1 !== undefined) {
    var protocol$2 = protocol$1;
    origin = protocol$2 !== "file:" ? protocol$2 + ("//" + host$1) : undefined;
  } else {
    origin = undefined;
  }
  var match$5 = relative && isNone(host$1);
  var match$6 = relative && isNone(hostname);
  var match$7 = relative && isNone(port$1);
  var url_004 = /* host */match$5 ? $$location$1[/* host */4] : host$1;
  var url_005 = /* hostname */match$6 ? $$location$1[/* hostname */5] : hostname;
  var url_006 = /* port */match$7 ? $$location$1[/* port */6] : port$1;
  var url = /* record */[
    /* href */"",
    /* protocol */protocol$1,
    /* slashes */slashes$1,
    /* origin */origin,
    url_004,
    url_005,
    url_006,
    /* auth */auth,
    /* username */username$3,
    /* password */password$2,
    /* pathname */pathname$1,
    /* querystring */querystring,
    /* hash */hash
  ];
  return /* record */[
          /* href */toString(url),
          /* protocol */protocol$1,
          /* slashes */slashes$1,
          /* origin */origin,
          url_004,
          url_005,
          url_006,
          /* auth */auth,
          /* username */username$3,
          /* password */password$2,
          /* pathname */pathname$1,
          /* querystring */querystring,
          /* hash */hash
        ];
}

function make(protocol, $staropt$star, host, hostname, port, auth, username, password, pathname, querystring, hash, param) {
  var slashes = $staropt$star !== undefined ? $staropt$star : false;
  return makeWithLocation(protocol, slashes, host, hostname, port, auth, username, password, pathname, querystring, hash, undefined);
}

function fromString($$location, address) {
  var match = extractProtocol(address);
  var slashes = match[1];
  var rest = getWithDefault(match[2], "");
  var exit = 0;
  var match$1 = exec(/* :: */[
        hash,
        /* :: */[
          querystring,
          /* :: */[
            slashes ? pathnameWhenSlashes : pathnameWhenNoSlashes,
            /* :: */[
              auth,
              /* :: */[
                host,
                /* :: */[
                  port,
                  /* :: */[
                    hostname,
                    /* [] */0
                  ]
                ]
              ]
            ]
          ]
        ]
      ], /* [] */0, rest);
  if (match$1) {
    var match$2 = match$1[1];
    if (match$2) {
      var match$3 = match$2[1];
      if (match$3) {
        var match$4 = match$3[1];
        if (match$4) {
          var match$5 = match$4[1];
          if (match$5) {
            var match$6 = match$5[1];
            if (match$6) {
              var match$7 = match$6[1];
              if (match$7 && !match$7[1]) {
                var port$1 = flatMap(match$2[0], toInt);
                return makeWithLocation(match[0], slashes, match$3[0], match$1[0], port$1, match$4[0], undefined, undefined, match$5[0], match$6[0], match$7[0], $$location);
              } else {
                exit = 1;
              }
            } else {
              exit = 1;
            }
          } else {
            exit = 1;
          }
        } else {
          exit = 1;
        }
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    throw [
          Caml_builtin_exceptions.match_failure,
          /* tuple */[
            "Url.re",
            557,
            6
          ]
        ];
  }
  
}

exports.empty = empty;
exports.resolvePathname = resolvePathname;
exports.toString = toString;
exports.makeWithLocation = makeWithLocation;
exports.make = make;
exports.fromString = fromString;
/* protocolRegExp Not a pure module */
